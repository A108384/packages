#!/usr/bin/env perl

# ABSTRACT: Find and return all unique package names in input file with highest version string
# PODNAME: get_unique_updates.pl

use Modern::Perl;

use FindBin;
use lib "$FindBin::RealBin/lib";
use GetUniqueLines;

use Getopt::Long;
use Pod::Usage;

BEGIN {
    # First, check if all the required modules have
    # been installed inthe system this script will run on.
    my @import_modules = (
        'FindBin',
        'Modern::Perl',
        'Getopt::Long',
        'Pod::Usage',
        'ExtUtils::Installed',
        );

    for my $module ( @import_modules ) {
        eval 'require ' . $module;
        if ($@) {
          # problems finding module
        #   say "Cant find $module";
          print qq{
          $module does not seem to be installed in this system. Please install the module and try again.\n
          First install cpanm with
            curl -L https://cpanmin.us | perl - --sudo App::cpanminus\n
          Then install the missing module like so:
            sudo cpanm $module};
            exit 1;
        }
    }
}

my $successful_parse = GetOptions(
   'help|?'        => \my $help,
   man             => \my $man,
   'input-file=s'  => \my $input_file,
   'output-dir=s'  => \( my $output_dir = "$FindBin::RealBin" ),
   'output-file=s' => \my $output_file
  )
  or pod2usage(2);

if ( !$successful_parse || ( @ARGV > 2 ) ) {
   die qq{Usage: $0 [ --input-file input_filename --output-dir output_directory]\n};
}

if ( !defined $input_file ) {
   die qq{   An input file is required\n
      Usage: $0 [ --input-file input_filename --output-dir output_directory --output-file output_filename]\n};
}

pod2usage(1)                              if $help;
pod2usage( -exitval => 0, -verbose => 2 ) if $man;

unless ( -e -f -r $input_file ) {
   die("Unable to read '$input_file': $!\n");
}

unless ( GetUniqueLines::check_file_format($input_file) ) {
   die("File '$input_file' is not in the expected markdown format\n");
}

my %packages = GetUniqueLines::get_unique_lines($input_file);
my $pkg_href = \%packages;

# Write to STDOUT, unless output file provided
if ($output_file) {
   my $file_path = $output_dir . '/' . $output_file;
   GetUniqueLines::write_to_file( $file_path, $pkg_href );
} else {
   GetUniqueLines::write_to_stdout($pkg_href);
}

__END__
=pod

=encoding UTF-8

=head1 NAME

get_unique_updates.pl

=head1 SYNOPSIS

get_unique_updates.pl --input-file ~/temp/ --output-dir ~/temp

 Options:
   -help                Brief help message
   -man                 Full documentation
   --input-file         The file to parse, generated by worklog.py (required)
   --output-dir         Directory to store output file (defaults to the directory this script is in, only used if --output-file is provided)
   --output-file         The name of the file to save the output to. If this is not provided, the list of packages will be printed to STDOUT.

=head1 DESCRIPTION

Solus uses worklog.py to generate a list of packages that were updated in a given timeframe. The file it generates includes all updates to every package.

This script takes that file as input and returns a list to STDOUT or a file that has only one line per package. That line will be the latest version built for the package.

You must use the markdown output type with worklog.py for use with this script. e.g.

    ./worklog.py --format md builds 2024-02-04 now >| ~/temp/solus_builds_2024-02-04.md

Examples:

    get_unique_updates.pl --input-file ~/temp/solus_builds_2024-02-04.md

    get_unique_updates.pl --input-file ~/temp/solus_builds_2024-02-04.md --output-dir ~/temp --output-file solus_unique_builds_2024-02-04.md
