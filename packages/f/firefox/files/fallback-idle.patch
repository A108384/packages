
# HG changeset patch
# User stransky <stransky@redhat.com>
# Date 1698958462 0
# Node ID a8eb7938131dec30c0043b6eeed4ca9727b3dcda
# Parent  2af5b81322999f70d9fdd62af68735ddc00d0c4d
Bug 1861615 [Linux] Fallback to another idle service type from UserIdleServiceMutter::PollIdleTime() r=emilio, a=dsmith

Allow to switch to another idle service type if UserIdleServiceMutter::PollIdleTime() fails. We recently see that failures on Mozilla try servers as:
Failed to call GetIdletime(): GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name org.gnome.Mutter.IdleMonitor was not provided by any .service files

Differential Revision: https://phabricator.services.mozilla.com/D192208

diff --git a/widget/gtk/nsUserIdleServiceGTK.cpp b/widget/gtk/nsUserIdleServiceGTK.cpp
--- a/widget/gtk/nsUserIdleServiceGTK.cpp
+++ b/widget/gtk/nsUserIdleServiceGTK.cpp
@@ -71,18 +71,17 @@ class UserIdleServiceX11 : public UserId
       return true;
     }
     // If we get here, we couldn't get to XScreenSaver:
     MOZ_LOG(sIdleLog, LogLevel::Warning,
             ("XSSQueryExtension returned false!\n"));
     return false;
   }
 
-  bool ProbeImplementation(
-      RefPtr<nsUserIdleServiceGTK> aUserIdleServiceGTK) override {
+  bool ProbeImplementation() override {
     MOZ_LOG(sIdleLog, LogLevel::Info,
             ("UserIdleServiceX11::UserIdleServiceX11()\n"));
 
     if (!mozilla::widget::GdkIsX11Display()) {
       return false;
     }
 
     // This will leak - See comments in ~UserIdleServiceX11().
@@ -111,21 +110,23 @@ class UserIdleServiceX11 : public UserId
       MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSQueryInfo!\n"));
     }
     if (!mXSSQueryExtension || !mXSSAllocInfo || !mXSSQueryInfo) {
       // We're missing X11 symbols
       return false;
     }
 
     // UserIdleServiceX11 uses sync init, confirm it now.
-    aUserIdleServiceGTK->AcceptServiceCallback();
+    mUserIdleServiceGTK->AcceptServiceCallback();
     return true;
   }
 
- protected:
+  explicit UserIdleServiceX11(nsUserIdleServiceGTK* aUserIdleService)
+      : UserIdleServiceImpl(aUserIdleService){};
+
   ~UserIdleServiceX11() {
 #  ifdef MOZ_X11
     if (mXssInfo) {
       XFree(mXssInfo);
     }
 #  endif
 
 // It is not safe to unload libXScrnSaver until each display is closed because
@@ -161,17 +162,17 @@ class UserIdleServiceMutter : public Use
     if (!mPollInProgress) {
       mPollInProgress = true;
       DBusProxyCall(mProxy, "GetIdletime", nullptr, G_DBUS_CALL_FLAGS_NONE, -1,
                     mCancellable)
           ->Then(
               GetCurrentSerialEventTarget(), __func__,
               // It's safe to capture this as we use mCancellable to stop
               // listening.
-              [self = RefPtr{this}, this](RefPtr<GVariant>&& aResult) {
+              [this](RefPtr<GVariant>&& aResult) {
                 if (!g_variant_is_of_type(aResult, G_VARIANT_TYPE_TUPLE) ||
                     g_variant_n_children(aResult) != 1) {
                   MOZ_LOG(sIdleLog, LogLevel::Info,
                           ("PollIdleTime() Unexpected params type: %s\n",
                            g_variant_get_type_string(aResult)));
                   mLastIdleTime = 0;
                   return;
                 }
@@ -188,57 +189,57 @@ class UserIdleServiceMutter : public Use
                 if (idleTime > std::numeric_limits<uint32_t>::max()) {
                   idleTime = std::numeric_limits<uint32_t>::max();
                 }
                 mLastIdleTime = idleTime;
                 mPollInProgress = false;
                 MOZ_LOG(sIdleLog, LogLevel::Info,
                         ("Async handler got %d\n", mLastIdleTime));
               },
-              [self = RefPtr{this}, this](GUniquePtr<GError>&& aError) {
+              [this](GUniquePtr<GError>&& aError) {
                 mPollInProgress = false;
                 g_warning("Failed to call GetIdletime(): %s\n",
                           aError->message);
+                mUserIdleServiceGTK->RejectAndTryNextServiceCallback();
               });
     }
 
     *aIdleTime = mLastIdleTime;
     MOZ_LOG(sIdleLog, LogLevel::Info,
             ("PollIdleTime() returns %d\n", *aIdleTime));
     return true;
   }
 
-  bool ProbeImplementation(
-      RefPtr<nsUserIdleServiceGTK> aUserIdleServiceGTK) override {
+  bool ProbeImplementation() override {
     MOZ_LOG(sIdleLog, LogLevel::Info,
             ("UserIdleServiceMutter::UserIdleServiceMutter()\n"));
 
     mCancellable = dont_AddRef(g_cancellable_new());
     CreateDBusProxyForBus(
         G_BUS_TYPE_SESSION,
         GDBusProxyFlags(G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |
                         G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES),
         nullptr, "org.gnome.Mutter.IdleMonitor",
         "/org/gnome/Mutter/IdleMonitor/Core", "org.gnome.Mutter.IdleMonitor",
         mCancellable)
         ->Then(
             GetCurrentSerialEventTarget(), __func__,
-            [self = RefPtr{this}, service = RefPtr{aUserIdleServiceGTK}](
-                RefPtr<GDBusProxy>&& aProxy) {
-              self->mProxy = std::move(aProxy);
-              service->AcceptServiceCallback();
+            [this](RefPtr<GDBusProxy>&& aProxy) {
+              mProxy = std::move(aProxy);
+              mUserIdleServiceGTK->AcceptServiceCallback();
             },
-            [self = RefPtr{this}, service = RefPtr{aUserIdleServiceGTK}](
-                GUniquePtr<GError>&& aError) {
-              service->RejectAndTryNextServiceCallback();
+            [this](GUniquePtr<GError>&& aError) {
+              mUserIdleServiceGTK->RejectAndTryNextServiceCallback();
             });
     return true;
   }
 
- protected:
+  explicit UserIdleServiceMutter(nsUserIdleServiceGTK* aUserIdleService)
+      : UserIdleServiceImpl(aUserIdleService){};
+
   ~UserIdleServiceMutter() {
     if (mCancellable) {
       g_cancellable_cancel(mCancellable);
       mCancellable = nullptr;
     }
     mProxy = nullptr;
   }
 
@@ -254,29 +255,29 @@ void nsUserIdleServiceGTK::ProbeService(
   MOZ_LOG(sIdleLog, LogLevel::Info,
           ("nsUserIdleServiceGTK::ProbeService() mIdleServiceType %d\n",
            mIdleServiceType));
   MOZ_ASSERT(!mIdleService);
 
   switch (mIdleServiceType) {
 #ifdef MOZ_ENABLE_DBUS
     case IDLE_SERVICE_MUTTER:
-      mIdleService = new UserIdleServiceMutter();
+      mIdleService = MakeUnique<UserIdleServiceMutter>(this);
       break;
 #endif
 #ifdef MOZ_X11
     case IDLE_SERVICE_XSCREENSAVER:
-      mIdleService = new UserIdleServiceX11();
+      mIdleService = MakeUnique<UserIdleServiceX11>(this);
       break;
 #endif
     default:
       return;
   }
 
-  if (!mIdleService->ProbeImplementation(this)) {
+  if (!mIdleService->ProbeImplementation()) {
     RejectAndTryNextServiceCallback();
   }
 }
 
 void nsUserIdleServiceGTK::AcceptServiceCallback() {
   MOZ_LOG(sIdleLog, LogLevel::Info,
           ("nsUserIdleServiceGTK::AcceptServiceCallback() type %d\n",
            mIdleServiceType));
@@ -286,25 +287,25 @@ void nsUserIdleServiceGTK::AcceptService
 void nsUserIdleServiceGTK::RejectAndTryNextServiceCallback() {
   MOZ_LOG(sIdleLog, LogLevel::Info,
           ("nsUserIdleServiceGTK::RejectAndTryNextServiceCallback() type %d\n",
            mIdleServiceType));
 
   // Delete recent non-working service
   MOZ_ASSERT(mIdleService, "Nothing to reject?");
   mIdleService = nullptr;
+  mIdleServiceInitialized = false;
 
   mIdleServiceType++;
   if (mIdleServiceType < IDLE_SERVICE_NONE) {
     MOZ_LOG(sIdleLog, LogLevel::Info,
             ("nsUserIdleServiceGTK try next idle service\n"));
     ProbeService();
   } else {
     MOZ_LOG(sIdleLog, LogLevel::Info, ("nsUserIdleServiceGTK failed\n"));
-    mIdleServiceInitialized = false;
   }
 }
 
 bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
   if (!mIdleServiceInitialized) {
     return false;
   }
   return mIdleService->PollIdleTime(aIdleTime);
diff --git a/widget/gtk/nsUserIdleServiceGTK.h b/widget/gtk/nsUserIdleServiceGTK.h
--- a/widget/gtk/nsUserIdleServiceGTK.h
+++ b/widget/gtk/nsUserIdleServiceGTK.h
@@ -11,24 +11,26 @@
 #include "nsUserIdleService.h"
 #include "mozilla/AppShutdown.h"
 #include "mozilla/UniquePtr.h"
 
 class nsUserIdleServiceGTK;
 
 class UserIdleServiceImpl {
  public:
-  NS_INLINE_DECL_REFCOUNTING(UserIdleServiceImpl);
+  explicit UserIdleServiceImpl(nsUserIdleServiceGTK* aUserIdleService)
+      : mUserIdleServiceGTK(aUserIdleService){};
 
   virtual bool PollIdleTime(uint32_t* aIdleTime) = 0;
-  virtual bool ProbeImplementation(
-      RefPtr<nsUserIdleServiceGTK> aUserIdleServiceGTK) = 0;
+  virtual bool ProbeImplementation() = 0;
+
+  virtual ~UserIdleServiceImpl() = default;
 
  protected:
-  virtual ~UserIdleServiceImpl() = default;
+  nsUserIdleServiceGTK* mUserIdleServiceGTK;
 };
 
 #define IDLE_SERVICE_MUTTER 0
 #define IDLE_SERVICE_XSCREENSAVER 1
 #define IDLE_SERVICE_NONE 2
 
 class nsUserIdleServiceGTK : public nsUserIdleService {
  public:
@@ -58,17 +60,17 @@ class nsUserIdleServiceGTK : public nsUs
   void RejectAndTryNextServiceCallback();
 
  protected:
   nsUserIdleServiceGTK() = default;
 
  private:
   ~nsUserIdleServiceGTK() = default;
 
-  RefPtr<UserIdleServiceImpl> mIdleService;
+  mozilla::UniquePtr<UserIdleServiceImpl> mIdleService;
 #ifdef MOZ_ENABLE_DBUS
   int mIdleServiceType = IDLE_SERVICE_MUTTER;
 #else
   int mIdleServiceType = IDLE_SERVICE_XSCREENSAVER;
 #endif
   // We have a working idle service.
   bool mIdleServiceInitialized = false;
 };

