From 4c872238d9edc9bbf7a6aeddffc1c9f5f9aaa2e2 Mon Sep 17 00:00:00 2001
From: Recep Aslantas <info@recp.me>
Date: Sun, 31 Mar 2024 04:22:42 +0300
Subject: [PATCH 1/3] dont use I macro defined in standard

---
 docs/source/vec2.rst       | 12 +++++------
 docs/source/vec3.rst       | 22 ++++++++++----------
 docs/source/vec4.rst       | 14 ++++++-------
 include/cglm/call/vec2.h   |  4 ++--
 include/cglm/call/vec3.h   |  6 +++---
 include/cglm/call/vec4.h   |  4 ++--
 include/cglm/struct/vec2.h | 16 +++++++--------
 include/cglm/struct/vec3.h | 10 ++++-----
 include/cglm/struct/vec4.h | 20 +++++++++---------
 include/cglm/vec2.h        | 26 +++++++++++------------
 include/cglm/vec3.h        | 42 +++++++++++++++++++-------------------
 include/cglm/vec4.h        | 26 +++++++++++------------
 src/vec2.c                 |  8 ++++----
 src/vec3.c                 | 12 +++++------
 src/vec4.c                 |  8 ++++----
 15 files changed, 115 insertions(+), 115 deletions(-)

diff --git a/docs/source/vec2.rst b/docs/source/vec2.rst
index 95615d11..e9e38caa 100644
--- a/docs/source/vec2.rst
+++ b/docs/source/vec2.rst
@@ -397,16 +397,16 @@ Functions documentation
       | *[in]*  **src**  pointer to an array of floats
       | *[out]* **dest** destination vector
 
-.. c:function:: void glm_vec2_reflect(vec2 I, vec2 N, vec2 dest) 
+.. c:function:: void glm_vec2_reflect(vec2 v, vec2 n, vec2 dest)
 
     Reflection vector using an incident ray and a surface normal
 
     Parameters:
-      | *[in]*  **I**     incident vector
-      | *[in]*  **N**     *❗️ normalized ❗️* normal vector
+      | *[in]*  **v**     incident vector
+      | *[in]*  **n**     *❗️ normalized ❗️* normal vector
       | *[out]* **dest**  destination: reflection result
 
-.. c:function:: bool glm_vec2_refract(vec2 I, vec2 N, float eta, vec2 dest)
+.. c:function:: bool glm_vec2_refract(vec2 v, vec2 n, float eta, vec2 dest)
 
     Computes refraction vector for an incident vector and a surface normal.
    
@@ -415,8 +415,8 @@ Functions documentation
     Otherwise, computes refraction vector, stores it in dest, and returns true.
 
     Parameters:
-      | *[in]*  **I**     *❗️ normalized ❗️* incident vector
-      | *[in]*  **N**     *❗️ normalized ❗️* normal vector
+      | *[in]*  **v**     *❗️ normalized ❗️* incident vector
+      | *[in]*  **n**     *❗️ normalized ❗️* normal vector
       | *[in]*  **eta**   ratio of indices of refraction (incident/transmitted)
       | *[out]* **dest**  refraction vector if refraction occurs; zero vector otherwise
 
diff --git a/docs/source/vec3.rst b/docs/source/vec3.rst
index 91c16b9a..0b989b88 100644
--- a/docs/source/vec3.rst
+++ b/docs/source/vec3.rst
@@ -516,26 +516,26 @@ Functions documentation
       | *[in]*  **src**  pointer to an array of floats
       | *[out]* **dest** destination vector
 
-.. c:function:: void glm_vec3_faceforward(vec3 N, vec3 I, vec3 Nref, vec3 dest)
+.. c:function:: void glm_vec3_faceforward(vec3 n, vec3 v, vec3 nref, vec3 dest)
 
     A vector pointing in the same direction as another
 
     Parameters:
-      | *[in]*  **N**     vector to orient
-      | *[in]*  **I**     incident vector
-      | *[in]*  **Nref**  reference vector
+      | *[in]*  **n**     vector to orient
+      | *[in]*  **v**     incident vector
+      | *[in]*  **nref**  reference vector
       | *[out]* **dest**  destination: oriented vector, pointing away from the surface.
 
-.. c:function:: void glm_vec3_reflect(vec3 I, vec3 N, vec3 dest) 
+.. c:function:: void glm_vec3_reflect(vec3 v, vec3 n, vec3 dest)
 
     Reflection vector using an incident ray and a surface normal
 
     Parameters:
-      | *[in]*  **I**     incident vector
-      | *[in]*  **N**     *❗️ normalized ❗️* normal vector
+      | *[in]*  **v**     incident vector
+      | *[in]*  **n**     *❗️ normalized ❗️* normal vector
       | *[out]* **dest**  destination: reflection result
 
-.. c:function:: bool glm_vec3_refract(vec3 I, vec3 N, float eta, vec3 dest)
+.. c:function:: bool glm_vec3_refract(vec3 v, vec3 n, float eta, vec3 dest)
 
     
     Computes refraction vector for an incident vector and a surface normal.
@@ -545,10 +545,10 @@ Functions documentation
     Otherwise, computes refraction vector, stores it in dest, and returns true.
 
     Parameters:
-      | *[in]*  **I**     *❗️ normalized ❗️* incident vector
-      | *[in]*  **N**     *❗️ normalized ❗️* normal vector
+      | *[in]*  **v**     *❗️ normalized ❗️* incident vector
+      | *[in]*  **n**     *❗️ normalized ❗️* normal vector
       | *[in]*  **eta**   ratio of indices of refraction (incident/transmitted)
       | *[out]* **dest**  refraction vector if refraction occurs; zero vector otherwise
 
     Returns:
-      returns true if refraction occurs; false if total internal reflection occurs.
\ No newline at end of file
+      returns true if refraction occurs; false if total internal reflection occurs.
diff --git a/docs/source/vec4.rst b/docs/source/vec4.rst
index 04c3a82e..9035a3de 100644
--- a/docs/source/vec4.rst
+++ b/docs/source/vec4.rst
@@ -427,16 +427,16 @@ Functions documentation
       | *[in]*  **src**  pointer to an array of floats
       | *[out]* **dest** destination vector
 
-.. c:function:: bool glm_vec4_reflect(vec4 I, vec4 N, vec4 dest) 
+.. c:function:: bool glm_vec4_reflect(vec4 v, vec4 n, vec4 dest)
 
     Reflection vector using an incident ray and a surface normal
 
     Parameters:
-      | *[in]*  **I**     incident vector
-      | *[in]*  **N**     *❗️ normalized ❗️* normal vector
+      | *[in]*  **v**     incident vector
+      | *[in]*  **n**     *❗️ normalized ❗️* normal vector
       | *[out]* **dest**  destination: reflection result
 
-.. c:function:: bool glm_vec4_refract(vec4 I, vec4 N, float eta, vec4 dest)
+.. c:function:: bool glm_vec4_refract(vec4 v, vec4 n, float eta, vec4 dest)
 
     computes refraction vector for an incident vector and a surface normal.
    
@@ -449,10 +449,10 @@ Functions documentation
     the 'w' component should manually adjust 'dest' after calling this function.
 
     Parameters:
-      | *[in]*  **I**     *❗️ normalized ❗️* incident vector
-      | *[in]*  **N**     *❗️ normalized ❗️* normal vector
+      | *[in]*  **v**     *❗️ normalized ❗️* incident vector
+      | *[in]*  **n**     *❗️ normalized ❗️* normal vector
       | *[in]*  **eta**   ratio of indices of refraction (incident/transmitted)
       | *[out]* **dest**  refraction vector if refraction occurs; zero vector otherwise
 
     Returns:
-      returns true if refraction occurs; false if total internal reflection occurs.
\ No newline at end of file
+      returns true if refraction occurs; false if total internal reflection occurs.
diff --git a/include/cglm/call/vec2.h b/include/cglm/call/vec2.h
index 2343d145..507f042e 100644
--- a/include/cglm/call/vec2.h
+++ b/include/cglm/call/vec2.h
@@ -199,11 +199,11 @@ glmc_vec2_make(const float * __restrict src, vec2 dest);
 
 CGLM_EXPORT
 void
-glmc_vec2_reflect(vec2 I, vec2 N, vec2 dest);
+glmc_vec2_reflect(vec2 v, vec2 n, vec2 dest);
 
 CGLM_EXPORT
 bool
-glmc_vec2_refract(vec2 I, vec2 N, float eta, vec2 dest);
+glmc_vec2_refract(vec2 v, vec2 n, float eta, vec2 dest);
 
 #ifdef __cplusplus
 }
diff --git a/include/cglm/call/vec3.h b/include/cglm/call/vec3.h
index 2bde3ba6..bb5a5d70 100644
--- a/include/cglm/call/vec3.h
+++ b/include/cglm/call/vec3.h
@@ -336,15 +336,15 @@ glmc_vec3_make(const float * __restrict src, vec3 dest);
 
 CGLM_EXPORT
 void
-glmc_vec3_faceforward(vec3 N, vec3 I, vec3 Nref, vec3 dest);
+glmc_vec3_faceforward(vec3 n, vec3 v, vec3 nref, vec3 dest);
 
 CGLM_EXPORT
 void
-glmc_vec3_reflect(vec3 I, vec3 N, vec3 dest);
+glmc_vec3_reflect(vec3 v, vec3 n, vec3 dest);
 
 CGLM_EXPORT
 bool
-glmc_vec3_refract(vec3 I, vec3 N, float eta, vec3 dest);
+glmc_vec3_refract(vec3 v, vec3 n, float eta, vec3 dest);
 
 #ifdef __cplusplus
 }
diff --git a/include/cglm/call/vec4.h b/include/cglm/call/vec4.h
index d121bea0..a976e945 100644
--- a/include/cglm/call/vec4.h
+++ b/include/cglm/call/vec4.h
@@ -313,11 +313,11 @@ glmc_vec4_make(const float * __restrict src, vec4 dest);
 
 CGLM_EXPORT
 void
-glmc_vec4_reflect(vec4 I, vec4 N, vec4 dest);
+glmc_vec4_reflect(vec4 v, vec4 n, vec4 dest);
 
 CGLM_EXPORT
 bool
-glmc_vec4_refract(vec4 I, vec4 N, float eta, vec4 dest);
+glmc_vec4_refract(vec4 v, vec4 n, float eta, vec4 dest);
 
 #ifdef __cplusplus
 }
diff --git a/include/cglm/struct/vec2.h b/include/cglm/struct/vec2.h
index 3540d32e..e1190e2c 100644
--- a/include/cglm/struct/vec2.h
+++ b/include/cglm/struct/vec2.h
@@ -54,8 +54,8 @@
    CGLM_INLINE vec2s glms_vec2_clamp(vec2s v, float minVal, float maxVal)
    CGLM_INLINE vec2s glms_vec2_lerp(vec2s from, vec2s to, float t)
    CGLM_INLINE vec2s glms_vec2_make(float * restrict src)
-   CGLM_INLINE vec2s glms_vec2_reflect(vec2s I, vec2s N)
-   CGLM_INLINE bool  glms_vec2_refract(vec2s I, vec2s N, float eta, vec2s *dest)
+   CGLM_INLINE vec2s glms_vec2_reflect(vec2s v, vec2s n)
+   CGLM_INLINE bool  glms_vec2_refract(vec2s v, vec2s n, float eta, vec2s *dest)
  */
 
 #ifndef cglms_vec2s_h
@@ -702,9 +702,9 @@ glms_vec2_(make)(const float * __restrict src) {
  */
 CGLM_INLINE
 vec2s
-glms_vec2_(reflect)(vec2s I, vec2s N) {
+glms_vec2_(reflect)(vec2s v, vec2s n) {
   vec2s dest;
-  glm_vec2_reflect(I.raw, N.raw, dest.raw);
+  glm_vec2_reflect(v.raw, n.raw, dest.raw);
   return dest;
 }
 
@@ -715,8 +715,8 @@ glms_vec2_(reflect)(vec2s I, vec2s N) {
  * occurs (angle too great given eta), dest is set to zero and returns false.
  * Otherwise, computes refraction vector, stores it in dest, and returns true.
  *
- * @param[in]  I    normalized incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    normalized incident vector
+ * @param[in]  n    normalized normal vector
  * @param[in]  eta  ratio of indices of refraction (incident/transmitted)
  * @param[out] dest refraction vector if refraction occurs; zero vector otherwise
  *
@@ -724,8 +724,8 @@ glms_vec2_(reflect)(vec2s I, vec2s N) {
  */
 CGLM_INLINE
 bool
-glms_vec2_(refract)(vec2s I, vec2s N, float eta, vec2s * __restrict dest) {
-  return glm_vec2_refract(I.raw, N.raw, eta, dest->raw);
+glms_vec2_(refract)(vec2s v, vec2s n, float eta, vec2s * __restrict dest) {
+  return glm_vec2_refract(v.raw, n.raw, eta, dest->raw);
 }
 
 #endif /* cglms_vec2s_h */
diff --git a/include/cglm/struct/vec3.h b/include/cglm/struct/vec3.h
index e1e0a29a..b7ce133e 100644
--- a/include/cglm/struct/vec3.h
+++ b/include/cglm/struct/vec3.h
@@ -76,9 +76,9 @@
    CGLM_INLINE vec3s glms_vec3_smoothinterpc(vec3s from, vec3s to, float t);
    CGLM_INLINE vec3s glms_vec3_swizzle(vec3s v, int mask);
    CGLM_INLINE vec3s glms_vec3_make(float * restrict src);
-   CGLM_INLINE vec3s glms_vec3_faceforward(vec3s N, vec3s I, vec3s Nref);
-   CGLM_INLINE vec3s glms_vec3_reflect(vec3s I, vec3s N);
-   CGLM_INLINE bool  glms_vec3_refract(vec3s I, vec3s N, float eta, vec3s *dest)
+   CGLM_INLINE vec3s glms_vec3_faceforward(vec3s n, vec3s v, vec3s nref);
+   CGLM_INLINE vec3s glms_vec3_reflect(vec3s v, vec3s n);
+   CGLM_INLINE bool  glms_vec3_refract(vec3s v, vec3s n, float eta, vec3s *dest)
 
  Convenient:
    CGLM_INLINE vec3s glms_cross(vec3s a, vec3s b);
@@ -1113,9 +1113,9 @@ glms_vec3_(faceforward)(vec3s N, vec3s I, vec3s Nref) {
  */
 CGLM_INLINE
 vec3s
-glms_vec3_(reflect)(vec3s I, vec3s N) {
+glms_vec3_(reflect)(vec3s v, vec3s n) {
   vec3s dest;
-  glm_vec3_reflect(I.raw, N.raw, dest.raw);
+  glm_vec3_reflect(v.raw, n.raw, dest.raw);
   return dest;
 }
 
diff --git a/include/cglm/struct/vec4.h b/include/cglm/struct/vec4.h
index 44314608..8b2ef007 100644
--- a/include/cglm/struct/vec4.h
+++ b/include/cglm/struct/vec4.h
@@ -67,8 +67,8 @@
    CGLM_INLINE vec4s glms_vec4_cubic(float s);
    CGLM_INLINE vec4s glms_vec4_swizzle(vec4s v, int mask);
    CGLM_INLINE vec4s glms_vec4_make(float * restrict src);
-   CGLM_INLINE vec4s glms_vec4_reflect(vec4s I, vec4s N);
-   CGLM_INLINE bool  glms_vec4_refract(vec4s I, vec4s N, float eta, vec4s *dest)
+   CGLM_INLINE vec4s glms_vec4_reflect(vec4s v, vec4s n);
+   CGLM_INLINE bool  glms_vec4_refract(vec4s v, vec4s n, float eta, vec4s *dest)
  */
 
 #ifndef cglms_vec4s_h
@@ -932,15 +932,15 @@ glms_vec4_(make)(const float * __restrict src) {
 /*!
  * @brief reflection vector using an incident ray and a surface normal
  *
- * @param[in]  I    incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    incident vector
+ * @param[in]  n    normalized normal vector
  * @returns reflection result
  */
 CGLM_INLINE
 vec4s
-glms_vec4_(reflect)(vec4s I, vec4s N) {
+glms_vec4_(reflect)(vec4s v, vec4s n) {
   vec4s dest;
-  glm_vec4_reflect(I.raw, N.raw, dest.raw);
+  glm_vec4_reflect(v.raw, n.raw, dest.raw);
   return dest;
 }
 
@@ -955,8 +955,8 @@ glms_vec4_(reflect)(vec4s I, vec4s N) {
  * incident vector 'I' in the output 'dest', users requiring the preservation of
  * the 'w' component should manually adjust 'dest' after calling this function.
  *
- * @param[in]  I    normalized incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    normalized incident vector
+ * @param[in]  n    normalized normal vector
  * @param[in]  eta  ratio of indices of refraction (incident/transmitted)
  * @param[out] dest refraction vector if refraction occurs; zero vector otherwise
  *
@@ -964,8 +964,8 @@ glms_vec4_(reflect)(vec4s I, vec4s N) {
  */
 CGLM_INLINE
 bool
-glms_vec4_(refract)(vec4s I, vec4s N, float eta, vec4s * __restrict dest) {
-  return glm_vec4_refract(I.raw, N.raw, eta, dest->raw);
+glms_vec4_(refract)(vec4s v, vec4s n, float eta, vec4s * __restrict dest) {
+  return glm_vec4_refract(v.raw, n.raw, eta, dest->raw);
 }
 
 #endif /* cglms_vec4s_h */
diff --git a/include/cglm/vec2.h b/include/cglm/vec2.h
index aeb9e913..a6d16038 100644
--- a/include/cglm/vec2.h
+++ b/include/cglm/vec2.h
@@ -55,8 +55,8 @@
    CGLM_INLINE void  glm_vec2_clamp(vec2 v, float minVal, float maxVal)
    CGLM_INLINE void  glm_vec2_lerp(vec2 from, vec2 to, float t, vec2 dest)
    CGLM_INLINE void  glm_vec2_make(float * restrict src, vec2 dest)
-   CGLM_INLINE void  glm_vec2_reflect(vec2 I, vec2 N, vec2 dest)
-   CGLM_INLINE void  glm_vec2_refract(vec2 I, vec2 N, float eta, vec2 dest)
+   CGLM_INLINE void  glm_vec2_reflect(vec2 v, vec2 n, vec2 dest)
+   CGLM_INLINE void  glm_vec2_refract(vec2 v, vec2 n, float eta, vec2 dest)
  */
 
 #ifndef cglm_vec2_h
@@ -716,16 +716,16 @@ glm_vec2_make(const float * __restrict src, vec2 dest) {
 /*!
  * @brief reflection vector using an incident ray and a surface normal
  *
- * @param[in]  I    incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    incident vector
+ * @param[in]  n    normalized normal vector
  * @param[out] dest destination vector for the reflection result
  */
 CGLM_INLINE
 void
-glm_vec2_reflect(vec2 I, vec2 N, vec2 dest) {
+glm_vec2_reflect(vec2 v, vec2 n, vec2 dest) {
   vec2 temp;
-  glm_vec2_scale(N, 2.0f * glm_vec2_dot(I, N), temp);
-  glm_vec2_sub(I, temp, dest);
+  glm_vec2_scale(n, 2.0f * glm_vec2_dot(v, n), temp);
+  glm_vec2_sub(v, temp, dest);
 }
 
 /*!
@@ -735,8 +735,8 @@ glm_vec2_reflect(vec2 I, vec2 N, vec2 dest) {
  * occurs (angle too great given eta), dest is set to zero and returns false.
  * Otherwise, computes refraction vector, stores it in dest, and returns true.
  *
- * @param[in]  I    normalized incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    normalized incident vector
+ * @param[in]  n    normalized normal vector
  * @param[in]  eta  ratio of indices of refraction (incident/transmitted)
  * @param[out] dest refraction vector if refraction occurs; zero vector otherwise
  *
@@ -744,10 +744,10 @@ glm_vec2_reflect(vec2 I, vec2 N, vec2 dest) {
  */
 CGLM_INLINE
 bool
-glm_vec2_refract(vec2 I, vec2 N, float eta, vec2 dest) {
+glm_vec2_refract(vec2 v, vec2 v, float eta, vec2 dest) {
   float ndi, eni, k;
 
-  ndi = glm_vec2_dot(N, I);
+  ndi = glm_vec2_dot(n, v);
   eni = eta * ndi;
   k   = 1.0f + eta * eta - eni * eni;
 
@@ -756,8 +756,8 @@ glm_vec2_refract(vec2 I, vec2 N, float eta, vec2 dest) {
     return false;
   }
 
-  glm_vec2_scale(I, eta, dest);
-  glm_vec2_mulsubs(N, eni + sqrtf(k), dest);
+  glm_vec2_scale(v, eta, dest);
+  glm_vec2_mulsubs(n, eni + sqrtf(k), dest);
   return true;
 }
 
diff --git a/include/cglm/vec3.h b/include/cglm/vec3.h
index 72bd3716..be4029b4 100644
--- a/include/cglm/vec3.h
+++ b/include/cglm/vec3.h
@@ -80,9 +80,9 @@
    CGLM_INLINE void  glm_vec3_smoothinterpc(vec3 from, vec3 to, float t, vec3 dest);
    CGLM_INLINE void  glm_vec3_swizzle(vec3 v, int mask, vec3 dest);
    CGLM_INLINE void  glm_vec3_make(float * restrict src, vec3 dest);
-   CGLM_INLINE void  glm_vec3_faceforward(vec3 N, vec3 I, vec3 Nref, vec3 dest);
-   CGLM_INLINE void  glm_vec3_reflect(vec3 I, vec3 N, vec3 dest);
-   CGLM_INLINE void  glm_vec3_refract(vec3 I, vec3 N, float eta, vec3 dest);
+   CGLM_INLINE void  glm_vec3_faceforward(vec3 n, vec3 v, vec3 nref, vec3 dest);
+   CGLM_INLINE void  glm_vec3_reflect(vec3 v, vec3 n, vec3 dest);
+   CGLM_INLINE void  glm_vec3_refract(vec3 v, vec3 n, float eta, vec3 dest);
 
  Convenient:
    CGLM_INLINE void  glm_cross(vec3 a, vec3 b, vec3 d);
@@ -1210,36 +1210,36 @@ glm_vec3_make(const float * __restrict src, vec3 dest) {
  *
  * orients a vector to point away from a surface as defined by its normal
  *
- * @param[in] N      vector to orient
- * @param[in] I      incident vector
- * @param[in] Nref   reference vector
+ * @param[in] n      vector to orient
+ * @param[in] v      incident vector
+ * @param[in] nref   reference vector
  * @param[out] dest  oriented vector, pointing away from the surface
  */
 CGLM_INLINE
 void
-glm_vec3_faceforward(vec3 N, vec3 I, vec3 Nref, vec3 dest) {
-  if (glm_vec3_dot(I, Nref) < 0.0f) {
+glm_vec3_faceforward(vec3 n, vec3 v, vec3 nref, vec3 dest) {
+  if (glm_vec3_dot(v, nref) < 0.0f) {
     /* N is facing away from I */
-    glm_vec3_copy(N, dest);
+    glm_vec3_copy(n, dest);
   } else {
     /* N is facing towards I, negate it */
-    glm_vec3_negate_to(N, dest);
+    glm_vec3_negate_to(n, dest);
   }
 }
 
 /*!
  * @brief reflection vector using an incident ray and a surface normal
  *
- * @param[in]  I    incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    incident vector
+ * @param[in]  n    normalized normal vector
  * @param[out] dest reflection result
  */
 CGLM_INLINE
 void
-glm_vec3_reflect(vec3 I, vec3 N, vec3 dest) {
+glm_vec3_reflect(vec3 v, vec3 n, vec3 dest) {
   vec3 temp;
-  glm_vec3_scale(N, 2.0f * glm_vec3_dot(I, N), temp);
-  glm_vec3_sub(I, temp, dest);
+  glm_vec3_scale(n, 2.0f * glm_vec3_dot(v, n), temp);
+  glm_vec3_sub(v, temp, dest);
 }
 
 /*!
@@ -1249,8 +1249,8 @@ glm_vec3_reflect(vec3 I, vec3 N, vec3 dest) {
  * occurs (angle too great given eta), dest is set to zero and returns false.
  * Otherwise, computes refraction vector, stores it in dest, and returns true.
  *
- * @param[in]  I    normalized incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    normalized incident vector
+ * @param[in]  n    normalized normal vector
  * @param[in]  eta  ratio of indices of refraction (incident/transmitted)
  * @param[out] dest refraction vector if refraction occurs; zero vector otherwise
  *
@@ -1258,10 +1258,10 @@ glm_vec3_reflect(vec3 I, vec3 N, vec3 dest) {
  */
 CGLM_INLINE
 bool
-glm_vec3_refract(vec3 I, vec3 N, float eta, vec3 dest) {
+glm_vec3_refract(vec3 v, vec3 n, float eta, vec3 dest) {
   float ndi, eni, k;
 
-  ndi = glm_vec3_dot(N, I);
+  ndi = glm_vec3_dot(n, v);
   eni = eta * ndi;
   k   = 1.0f + eta * eta - eni * eni;
 
@@ -1270,8 +1270,8 @@ glm_vec3_refract(vec3 I, vec3 N, float eta, vec3 dest) {
     return false;
   }
 
-  glm_vec3_scale(I, eta, dest);
-  glm_vec3_mulsubs(N, eni + sqrtf(k), dest);
+  glm_vec3_scale(v, eta, dest);
+  glm_vec3_mulsubs(n, eni + sqrtf(k), dest);
   return true;
 }
 
diff --git a/include/cglm/vec4.h b/include/cglm/vec4.h
index 4053b9f1..a53746e3 100644
--- a/include/cglm/vec4.h
+++ b/include/cglm/vec4.h
@@ -65,8 +65,8 @@
    CGLM_INLINE void  glm_vec4_smoothinterpc(vec4 from, vec4 to, float t, vec4 dest);
    CGLM_INLINE void  glm_vec4_swizzle(vec4 v, int mask, vec4 dest);
    CGLM_INLINE void  glm_vec4_make(float * restrict src, vec4 dest);
-   CGLM_INLINE void  glm_vec4_reflect(vec4 I, vec4 N, vec4 dest);
-   CGLM_INLINE void  glm_vec4_refract(vec4 I, vec4 N, float eta, vec4 dest);
+   CGLM_INLINE void  glm_vec4_reflect(vec4 v, vec4 n, vec4 dest);
+   CGLM_INLINE void  glm_vec4_refract(vec4 v, vec4 n, float eta, vec4 dest);
 
  DEPRECATED:
    glm_vec4_dup
@@ -1309,20 +1309,20 @@ glm_vec4_make(const float * __restrict src, vec4 dest) {
 /*!
  * @brief reflection vector using an incident ray and a surface normal
  *
- * @param[in]  I    incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    incident vector
+ * @param[in]  n    normalized normal vector
  * @param[out] dest destination vector for the reflection result
  */
 CGLM_INLINE
 void
-glm_vec4_reflect(vec4 I, vec4 N, vec4 dest) {
+glm_vec4_reflect(vec4 v, vec4 n, vec4 dest) {
   vec4 temp;
 
   /* TODO: direct simd touch */
-  glm_vec4_scale(N, 2.0f * glm_vec4_dot(I, N), temp);
-  glm_vec4_sub(I, temp, dest);
+  glm_vec4_scale(n, 2.0f * glm_vec4_dot(v, n), temp);
+  glm_vec4_sub(v, temp, dest);
 
-  dest[3] = I[3];
+  dest[3] = v[3];
 }
 
 /*!
@@ -1336,8 +1336,8 @@ glm_vec4_reflect(vec4 I, vec4 N, vec4 dest) {
  * incident vector 'I' in the output 'dest', users requiring the preservation of
  * the 'w' component should manually adjust 'dest' after calling this function.
  *
- * @param[in]  I    normalized incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    normalized incident vector
+ * @param[in]  n    normalized normal vector
  * @param[in]  eta  ratio of indices of refraction (incident/transmitted)
  * @param[out] dest refraction vector if refraction occurs; zero vector otherwise
  *
@@ -1345,10 +1345,10 @@ glm_vec4_reflect(vec4 I, vec4 N, vec4 dest) {
  */
 CGLM_INLINE
 bool
-glm_vec4_refract(vec4 I, vec4 N, float eta, vec4 dest) {
+glm_vec4_refract(vec4 v, vec4 n, float eta, vec4 dest) {
   float ndi, eni, k;
 
-  ndi = glm_vec4_dot(N, I);
+  ndi = glm_vec4_dot(n, v);
   eni = eta * ndi;
   k   = 1.0f + eta * eta - eni * eni;
 
@@ -1357,7 +1357,7 @@ glm_vec4_refract(vec4 I, vec4 N, float eta, vec4 dest) {
     return false;
   }
 
-  glm_vec4_scale(I, eta, dest);
+  glm_vec4_scale(v, eta, dest);
   glm_vec4_mulsubs(N, eni + sqrtf(k), dest);
   return true;
 }
diff --git a/src/vec2.c b/src/vec2.c
index 4f638a1b..b124f865 100644
--- a/src/vec2.c
+++ b/src/vec2.c
@@ -305,12 +305,12 @@ glmc_vec2_make(const float * __restrict src, vec2 dest) {
 
 CGLM_EXPORT
 void
-glmc_vec2_reflect(vec2 I, vec2 N, vec2 dest) {
-  glm_vec2_reflect(I, N, dest);
+glmc_vec2_reflect(vec2 v, vec2 n, vec2 dest) {
+  glm_vec2_reflect(v, n, dest);
 }
 
 CGLM_EXPORT
 bool
-glmc_vec2_refract(vec2 I, vec2 N, float eta, vec2 dest) {
-  return glm_vec2_refract(I, N, eta, dest);
+glmc_vec2_refract(vec2 v, vec2 n, float eta, vec2 dest) {
+  return glm_vec2_refract(v, n, eta, dest);
 }
diff --git a/src/vec3.c b/src/vec3.c
index a31ce3fb..c1316dcd 100644
--- a/src/vec3.c
+++ b/src/vec3.c
@@ -462,18 +462,18 @@ glmc_vec3_make(const float * __restrict src, vec3 dest) {
 
 CGLM_EXPORT
 void
-glmc_vec3_faceforward(vec3 N, vec3 I, vec3 Nref, vec3 dest) {
-  glm_vec3_faceforward(N, I, Nref, dest);
+glmc_vec3_faceforward(vec3 n, vec3 v, vec3 nref, vec3 dest) {
+  glm_vec3_faceforward(n, v, nref, dest);
 }
 
 CGLM_EXPORT
 void
-glmc_vec3_reflect(vec3 I, vec3 N, vec3 dest) {
-  glm_vec3_reflect(I, N, dest);
+glmc_vec3_reflect(vec3 v, vec3 n, vec3 dest) {
+  glm_vec3_reflect(v, n, dest);
 }
 
 CGLM_EXPORT
 bool
-glmc_vec3_refract(vec3 I, vec3 N, float eta, vec3 dest) {
-  return glm_vec3_refract(I, N, eta, dest);
+glmc_vec3_refract(vec3 v, vec3 n, float eta, vec3 dest) {
+  return glm_vec3_refract(v, n, eta, dest);
 }
diff --git a/src/vec4.c b/src/vec4.c
index de234627..cac66066 100644
--- a/src/vec4.c
+++ b/src/vec4.c
@@ -426,12 +426,12 @@ glmc_vec4_make(const float * __restrict src, vec4 dest) {
 
 CGLM_EXPORT
 void
-glmc_vec4_reflect(vec4 I, vec4 N, vec4 dest) {
-  glm_vec4_reflect(I, N, dest);
+glmc_vec4_reflect(vec4 v, vec4 n, vec4 dest) {
+  glm_vec4_reflect(v, n, dest);
 }
 
 CGLM_EXPORT
 bool
-glmc_vec4_refract(vec4 I, vec4 N, float eta, vec4 dest) {
-  return glm_vec4_refract(I, N, eta, dest);
+glmc_vec4_refract(vec4 v, vec4 n, float eta, vec4 dest) {
+  return glm_vec4_refract(v, n, eta, dest);
 }

From f388df7f3ed597c12bcfd4aee9c0077380c86b10 Mon Sep 17 00:00:00 2001
From: Recep Aslantas <info@recp.me>
Date: Sun, 31 Mar 2024 04:40:42 +0300
Subject: [PATCH 2/3] fix typos

---
 include/cglm/vec2.h | 2 +-
 include/cglm/vec4.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/cglm/vec2.h b/include/cglm/vec2.h
index a6d16038..aaac759f 100644
--- a/include/cglm/vec2.h
+++ b/include/cglm/vec2.h
@@ -744,7 +744,7 @@ glm_vec2_reflect(vec2 v, vec2 n, vec2 dest) {
  */
 CGLM_INLINE
 bool
-glm_vec2_refract(vec2 v, vec2 v, float eta, vec2 dest) {
+glm_vec2_refract(vec2 v, vec2 n, float eta, vec2 dest) {
   float ndi, eni, k;
 
   ndi = glm_vec2_dot(n, v);
diff --git a/include/cglm/vec4.h b/include/cglm/vec4.h
index a53746e3..e24675fc 100644
--- a/include/cglm/vec4.h
+++ b/include/cglm/vec4.h
@@ -1358,7 +1358,7 @@ glm_vec4_refract(vec4 v, vec4 n, float eta, vec4 dest) {
   }
 
   glm_vec4_scale(v, eta, dest);
-  glm_vec4_mulsubs(N, eni + sqrtf(k), dest);
+  glm_vec4_mulsubs(n, eni + sqrtf(k), dest);
   return true;
 }
 

From bf4c5b4e266e342f2831a10c815449a546863dc6 Mon Sep 17 00:00:00 2001
From: Recep Aslantas <info@recp.me>
Date: Sun, 31 Mar 2024 13:24:50 +0300
Subject: [PATCH 3/3] dont use I macro defined in standard

---
 include/cglm/struct/vec3.h | 18 +++++++++---------
 test/src/test_vec2.h       | 14 +++++++-------
 test/src/test_vec3.h       | 20 ++++++++++----------
 test/src/test_vec4.h       | 14 +++++++-------
 4 files changed, 33 insertions(+), 33 deletions(-)

diff --git a/include/cglm/struct/vec3.h b/include/cglm/struct/vec3.h
index b7ce133e..536af03e 100644
--- a/include/cglm/struct/vec3.h
+++ b/include/cglm/struct/vec3.h
@@ -1091,16 +1091,16 @@ glms_vec3_(make)(const float * __restrict src) {
  *
  * orients a vector to point away from a surface as defined by its normal
  *
- * @param[in] N      vector to orient.
- * @param[in] I      incident vector
- * @param[in] Nref   reference vector
+ * @param[in] n      vector to orient.
+ * @param[in] v      incident vector
+ * @param[in] nref   reference vector
  * @returns oriented vector, pointing away from the surface.
  */
 CGLM_INLINE
 vec3s
-glms_vec3_(faceforward)(vec3s N, vec3s I, vec3s Nref) {
+glms_vec3_(faceforward)(vec3s n, vec3s v, vec3s nref) {
   vec3s dest;
-  glm_vec3_faceforward(N.raw, I.raw, Nref.raw, dest.raw);
+  glm_vec3_faceforward(n.raw, v.raw, nref.raw, dest.raw);
   return dest;
 }
 
@@ -1126,8 +1126,8 @@ glms_vec3_(reflect)(vec3s v, vec3s n) {
  * occurs (angle too great given eta), dest is set to zero and returns false.
  * Otherwise, computes refraction vector, stores it in dest, and returns true.
  *
- * @param[in]  I    normalized incident vector
- * @param[in]  N    normalized normal vector
+ * @param[in]  v    normalized incident vector
+ * @param[in]  n    normalized normal vector
  * @param[in]  eta  ratio of indices of refraction (incident/transmitted)
  * @param[out] dest refraction vector if refraction occurs; zero vector otherwise
  *
@@ -1135,8 +1135,8 @@ glms_vec3_(reflect)(vec3s v, vec3s n) {
  */
 CGLM_INLINE
 bool
-glms_vec3_(refract)(vec3s I, vec3s N, float eta, vec3s * __restrict dest) {
-  return glm_vec3_refract(I.raw, N.raw, eta, dest->raw);
+glms_vec3_(refract)(vec3s v, vec3s n, float eta, vec3s * __restrict dest) {
+  return glm_vec3_refract(v.raw, n.raw, eta, dest->raw);
 }
 
 #endif /* cglms_vec3s_h */
diff --git a/test/src/test_vec2.h b/test/src/test_vec2.h
index d45962d2..8fd16b55 100644
--- a/test/src/test_vec2.h
+++ b/test/src/test_vec2.h
@@ -781,15 +781,15 @@ TEST_IMPL(GLM_PREFIX, vec2_reflect) {
 }
 
 TEST_IMPL(GLM_PREFIX, vec2_refract) {
-  vec2 I = {sqrtf(0.5f), -sqrtf(0.5f)}; /* Incoming vector at 45 degrees to normal */
-  vec2 N = {0.0f, 1.0f};                /* Surface normal */
-  vec2 dest;
+  vec2  v = {sqrtf(0.5f), -sqrtf(0.5f)}; /* Incoming vector at 45 degrees to normal */
+  vec2  N = {0.0f, 1.0f};                /* Surface normal */
+  vec2  dest;
   float eta;
   float r;
 
   /* Water to Air (eta = 1.33/1.0) */
   eta = 1.33f / 1.0f;
-  r = GLM(vec2_refract)(I, N, eta, dest);
+  r = GLM(vec2_refract)(v, N, eta, dest);
   // In 2D, we expect a similar bending behavior as in 3D, so we check dest[1]
   if (!(dest[0] == 0.0f && dest[1] == 0.0f)) {
     ASSERT(dest[1] < -sqrtf(0.5f)); // Refracted ray bends away from the normal
@@ -801,17 +801,17 @@ TEST_IMPL(GLM_PREFIX, vec2_refract) {
 
   /* Air to Glass (eta = 1.0 / 1.5) */
   eta = 1.0f / 1.5f;
-  r = GLM(vec2_refract)(I, N, eta, dest);
+  r = GLM(vec2_refract)(v, N, eta, dest);
   ASSERT(dest[1] < -sqrtf(0.5f)); // Expect bending towards the normal
 
   /* Glass to Water (eta = 1.5 / 1.33) */
   eta = 1.5f / 1.33f;
-  r = GLM(vec2_refract)(I, N, eta, dest);
+  r = GLM(vec2_refract)(v, N, eta, dest);
   ASSERT(dest[1] < -sqrtf(0.5f)); // Expect bending towards the normal, less bending than air to glass
 
   /* Diamond to Air (eta = 2.42 / 1.0) */
   eta = 2.42f / 1.0f;
-  r = GLM(vec2_refract)(I, N, eta, dest);
+  r = GLM(vec2_refract)(v, N, eta, dest);
   if (!(dest[0] == 0.0f && dest[1] == 0.0f)) {
     /* High potential for total internal reflection, but if it occurs, expect significant bending */
     ASSERT(dest[1] < -sqrtf(0.5f));
diff --git a/test/src/test_vec3.h b/test/src/test_vec3.h
index 33f746b7..2fffecd4 100644
--- a/test/src/test_vec3.h
+++ b/test/src/test_vec3.h
@@ -1843,12 +1843,12 @@ TEST_IMPL(GLM_PREFIX, vec3_make) {
 
 TEST_IMPL(GLM_PREFIX, vec3_faceforward) {
   vec3 N = {0.0f, 1.0f, 0.0f};
-  vec3 I = {1.0f, -1.0f, 0.0f};
+  vec3 v = {1.0f, -1.0f, 0.0f};
   vec3 Nref = {0.0f, -1.0f, 0.0f};
   vec3 dest;
 
-  GLM(vec3_faceforward)(N, I, Nref, dest);
-  ASSERT(dest[0] == 0.0f 
+  GLM(vec3_faceforward)(N, v, Nref, dest);
+  ASSERT(dest[0] == 0.0f
          && dest[1] == -1.0f
          && dest[2] == 0.0f); /* Expect N flipped */
 
@@ -1886,15 +1886,15 @@ TEST_IMPL(GLM_PREFIX, vec3_reflect) {
 }
 
 TEST_IMPL(GLM_PREFIX, vec3_refract) {
-  vec3 I = {sqrtf(0.5f), -sqrtf(0.5f), 0.0f}; /* Incoming vector at 45 degrees to normal */
-  vec3 N = {0.0f, 1.0f, 0.0f};                /* Surface normal */
-  vec3 dest;
+  vec3  v = {sqrtf(0.5f), -sqrtf(0.5f), 0.0f}; /* Incoming vector at 45 degrees to normal */
+  vec3  N = {0.0f, 1.0f, 0.0f};                /* Surface normal */
+  vec3  dest;
   float eta;
   bool  r;
 
   /* Water to Air (eta = 1.33/1.0) */
   eta = 1.33f / 1.0f;
-  r = GLM(vec3_refract)(I, N, eta, dest);
+  r = GLM(vec3_refract)(v, N, eta, dest);
   if (!(dest[0] == 0.0f && dest[1] == 0.0f && dest[2] == 0.0f)) {
     ASSERT(dest[1] < -sqrtf(0.5f));
     ASSERT(r == true);
@@ -1905,21 +1905,21 @@ TEST_IMPL(GLM_PREFIX, vec3_refract) {
 
   /* Air to Glass (eta = 1.0 / 1.5) */
   eta = 1.0f / 1.5f;
-  r = GLM(vec3_refract)(I, N, eta, dest);
+  r = GLM(vec3_refract)(v, N, eta, dest);
 
   /* Expect bending towards the normal */
   ASSERT(dest[1] < -sqrtf(0.5f));
 
   /* Glass to Water (eta = 1.5 / 1.33) */
   eta = 1.5f / 1.33f;
-  r = GLM(vec3_refract)(I, N, eta, dest);
+  r = GLM(vec3_refract)(v, N, eta, dest);
 
   /* Expect bending towards the normal, less bending than air to glass */
   ASSERT(dest[1] < -sqrtf(0.5f));
 
   /* Diamond to Air (eta = 2.42 / 1.0) */
   eta = 2.42f / 1.0f;
-  r = GLM(vec3_refract)(I, N, eta, dest);
+  r = GLM(vec3_refract)(v, N, eta, dest);
   if (!(dest[0] == 0.0f && dest[1] == 0.0f && dest[2] == 0.0f)) {
     /* High potential for total internal reflection, but if it occurs, expect significant bending */
     ASSERT(dest[1] < -sqrtf(0.5f));
diff --git a/test/src/test_vec4.h b/test/src/test_vec4.h
index 35234203..d95815a7 100644
--- a/test/src/test_vec4.h
+++ b/test/src/test_vec4.h
@@ -1571,15 +1571,15 @@ TEST_IMPL(GLM_PREFIX, vec4_reflect) {
 }
 
 TEST_IMPL(GLM_PREFIX, vec4_refract) {
-  vec4 I = {sqrtf(0.5f), -sqrtf(0.5f), 0.0f, 0.0f}; /* Incoming vector */
-  vec4 N = {0.0f, 1.0f, 0.0f, 0.0f};                /* Surface normal */
-  vec4 dest;
+  vec4  v = {sqrtf(0.5f), -sqrtf(0.5f), 0.0f, 0.0f}; /* Incoming vector */
+  vec4  N = {0.0f, 1.0f, 0.0f, 0.0f};                /* Surface normal */
+  vec4  dest;
   float eta;
   float r;
 
   /* Water to Air (eta = 1.33/1.0) */
   eta = 1.33f / 1.0f;
-  r = GLM(vec4_refract)(I, N, eta, dest);
+  r = GLM(vec4_refract)(v, N, eta, dest);
   if (!(dest[0] == 0.0f && dest[1] == 0.0f && dest[2] == 0.0f && dest[3] == 0.0f)) {
     ASSERT(dest[1] < -sqrtf(0.5f));
     ASSERT(r == true);
@@ -1590,17 +1590,17 @@ TEST_IMPL(GLM_PREFIX, vec4_refract) {
 
   /* Air to Glass (eta = 1.0 / 1.5) */
   eta = 1.0f / 1.5f;
-  r = GLM(vec4_refract)(I, N, eta, dest);
+  r = GLM(vec4_refract)(v, N, eta, dest);
   ASSERT(dest[1] < -sqrtf(0.5f)); // Expect bending towards the normal
 
   /* Glass to Water (eta = 1.5 / 1.33) */
   eta = 1.5f / 1.33f;
-  r = GLM(vec4_refract)(I, N, eta, dest);
+  r = GLM(vec4_refract)(v, N, eta, dest);
   ASSERT(dest[1] < -sqrtf(0.5f)); // Expect bending towards the normal, less bending than air to glass
 
   /* Diamond to Air (eta = 2.42 / 1.0) */
   eta = 2.42f / 1.0f;
-  r = GLM(vec4_refract)(I, N, eta, dest);
+  r = GLM(vec4_refract)(v, N, eta, dest);
   if (!(dest[0] == 0.0f && dest[1] == 0.0f && dest[2] == 0.0f && dest[3] == 0.0f)) {
     /* High potential for total internal reflection, but if it occurs, expect significant bending */
     ASSERT(dest[1] < -sqrtf(0.5f));
