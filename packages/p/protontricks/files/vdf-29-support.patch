From f7b1fa33b0438dbd72f7222703f8442e40edc510 Mon Sep 17 00:00:00 2001
From: Janne Pulkkinen <janne.pulkkinen@protonmail.com>
Date: Thu, 1 Aug 2024 19:48:41 +0300
Subject: [PATCH] Support appinfo.vdf V29

Steam beta introduced a new version of appinfo.vdf with a space-saving
optimization. Field keys are stored in a separate table at the end of
the file, with the actual VDF segments having to be parsed using the
table to map the indices to actual field names.

`vdf` library does not support serializing appinfo.vdf using this
format, at least yet, so just use appinfo.vdf V28 in tests for the time
being. This might need to be fixed in the future once appinfo.vdf V28 is
phased out.

Fixes #304
---
 src/protontricks/steam.py | 56 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/src/protontricks/steam.py b/src/protontricks/steam.py
index db47cd1..bcae17e 100644
--- a/src/protontricks/steam.py
+++ b/src/protontricks/steam.py
@@ -471,6 +471,7 @@ def find_legacy_steam_runtime_path(steam_root):
 
 APPINFO_STRUCT_HEADER = "<4sL"
 APPINFO_V28_STRUCT_SECTION = "<LLLLQ20sL20s"
+APPINFO_V29_STRUCT_SECTION = "<LLLLQ20sL20s"
 
 
 def iter_appinfo_sections(path):
@@ -506,6 +507,59 @@ def _iter_v28_appinfo(data, start):
             if i == len(data) - 4:
                 return
 
+    def _iter_v29_appinfo(data, start):
+        """
+        Parse and iterate appinfo.vdf version 29.
+        """
+        i = start
+
+        # The header contains the offset to the key table
+        key_table_offset = struct.unpack("<q", data[i:i+8])[0]
+        key_table = []
+
+        key_count = struct.unpack(
+            "<i", data[key_table_offset:key_table_offset+4]
+        )[0]
+
+        table_i = key_table_offset + 4
+        for _ in range(0, key_count):
+            key = bytearray()
+            while True:
+                key.append(data[table_i])
+                table_i += 1
+
+                if key[-1] == 0:
+                    key_table.append(
+                        key[0:-1].decode("utf-8", errors="replace")
+                    )
+                    break
+
+        i += 8
+
+        section_size = struct.calcsize(APPINFO_V29_STRUCT_SECTION)
+        while True:
+            # We don't need any of the fields besides 'entry_size',
+            # which is used to determine the length of the variable-length VDF
+            # field.
+            # Still, here they are for posterity's sake.
+            (appid, entry_size, infostate, last_updated, access_token,
+             sha_hash, change_number, vdf_sha_hash) = struct.unpack(
+                APPINFO_V29_STRUCT_SECTION, data[i:i+section_size])
+            vdf_section_size = entry_size - (section_size - 8)
+
+            i += section_size
+
+            vdf_d = vdf.binary_loads(
+                data[i:i+vdf_section_size], key_table=key_table
+            )
+            vdf_d = lower_dict(vdf_d)
+            yield vdf_d
+
+            i += vdf_section_size
+
+            if i == key_table_offset - 4:
+                return
+
     logger.debug("Loading appinfo.vdf in %s", path)
 
     # appinfo.vdf is not actually a (binary) VDF file, but a binary file
@@ -527,6 +581,8 @@ def _iter_v28_appinfo(data, start):
 
     if magic == b'(DV\x07':
         yield from _iter_v28_appinfo(data, i)
+    elif magic == b')DV\x07':
+        yield from _iter_v29_appinfo(data, i)
     else:
         raise SyntaxError(
             "Invalid file magic number. The appinfo.vdf version might not be "
